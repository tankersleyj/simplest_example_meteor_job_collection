waitQueue = JobCollection('waitQueue')


Meteor.startup ->
  waitQueue.startJobServer()
  waitQueue.processJobs 'callLongWaitTask', { pollInterval: 1 * 1000 }, (job, callback) ->
# ##### THIS IS WHERE THE WORK GETS DONE #####//
    console.log 'Job worker started, with .processJobs() '
    # Only called when there is a valid job
    #Run a meteor method as the task.
    Meteor.call 'longWait', (error, res) ->
      console.log 'longWait Method callback'
      if res
        console.log res
        #job.data is a data object the developer can pass when submitting up a new job.
        job.done()
      # Only mark the job done if we have a response
      if error
        console.log error
        job.cancel()
      return
    callback()
    # TODO: what is this? Can the dev modify this?
    return
  return


Meteor.methods
  triggerLongWaitTask: ->
    console.log 'Sumbitting task type "callLongWaitTask" '
    Job(waitQueue, 'callLongWaitTask', {}).save()
    # submit the job to status: "ready"
    return
  longWait: ->
    console.log 'Called Meteor method \'longWait\'. This will take some time to completed.'
    milliseconds = 30000
    fut = new Future
    #let's pretend the work takes 'milliseconds' time to complete.
    Meteor.setTimeout (->
      fut['return'] 'The return is delayed :' + milliseconds + 'ms'
      # return "waiting " + milliseconds + "ms to return"
      return
    ), milliseconds
    fut.wait()

# ---
# generated by js2coffee 2.2.0