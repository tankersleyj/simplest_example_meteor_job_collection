waitQueueChained = JobCollection('waitQueueChained')


Meteor.startup ->
  waitQueueChained.startJobServer()
  waitQueueChained.processJobs 'theWaitingTask', { pollInterval: 1 * 1000 }, (job, callback) ->
# ##### THIS IS WHERE THE WORK GETS DONE #####//
    console.log 'Job worker started, with .processJobs() '
    # Only called when there is a valid job
    #Run a meteor method as the task.
    Meteor.call 'chainedFunction', (error, res) ->
      console.log 'Method callback'
      if res
        console.log res
        #job.data is a data object the developer can pass when submitting up a new job.
        job.done()
      # Only mark the job done if we have a response
      if error
        console.log error
        job.cancel()
      return
    callback()
    # TODO: what is this? Can the dev modify this?
    return
  return


Meteor.methods
  triggerLongWaitChainedTask: ->
    console.log 'Sumbitting task type "callLongWaitTask" '
    Job(waitQueueChained, 'theWaitingTask', {}).save()
    # submit the job to status: "ready"
    return

  chainedFunction: ->
#just an intermediary wrapper between the other slow function.
    Meteor.call 'reallyLongWait'
    return

  reallyLongWait: ->
    console.log 'Called Meteor method \'longWait\'. This will take some time to completed.'
    milliseconds = 30000
    fut = new Future
    #let's pretend the work takes 'milliseconds' time to complete.
    Meteor.setTimeout (->
      fut.return 'The job completed after: ' + milliseconds + 'ms'
      # return "waiting " + milliseconds + "ms to return"
      return
    ), milliseconds
    fut.wait()

# ---
# generated by js2coffee 2.2.0